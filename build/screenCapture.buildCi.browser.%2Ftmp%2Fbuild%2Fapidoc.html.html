<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/flatiron/director">director (v1.2.8)</a>
</h1>
<h4>A client Side/Server Side Router</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.director">module director</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router">
            function <span class="apidocSignatureSpan">director.</span>Router
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.configure">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.dispatch">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.dispatch
            <span class="apidocSignatureSpan">(method, path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.extend">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.extend
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.insert">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.insert
            <span class="apidocSignatureSpan">(method, path, route, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.invoke">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.invoke
            <span class="apidocSignatureSpan">(fns, thisArg, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.mount">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.mount
            <span class="apidocSignatureSpan">(routes, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.param">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.param
            <span class="apidocSignatureSpan">(token, matcher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.path">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.path
            <span class="apidocSignatureSpan">(path, routesFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.route">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.route
            <span class="apidocSignatureSpan">(method, path, route)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.runlist">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.runlist
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.traverse">
            function <span class="apidocSignatureSpan">director.</span>Router.prototype.traverse
            <span class="apidocSignatureSpan">(method, path, routes, regexp, filter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router">
            function <span class="apidocSignatureSpan">director.</span>cli.Router
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router.prototype.configure">
            function <span class="apidocSignatureSpan">director.</span>cli.Router.prototype.configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router.prototype.dispatch">
            function <span class="apidocSignatureSpan">director.</span>cli.Router.prototype.dispatch
            <span class="apidocSignatureSpan">(method, path, tty, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.BadRequest">
            function <span class="apidocSignatureSpan">director.</span>http.BadRequest
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Forbidden">
            function <span class="apidocSignatureSpan">director.</span>http.Forbidden
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.MethodNotAllowed">
            function <span class="apidocSignatureSpan">director.</span>http.MethodNotAllowed
            <span class="apidocSignatureSpan">(allowed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotAcceptable">
            function <span class="apidocSignatureSpan">director.</span>http.NotAcceptable
            <span class="apidocSignatureSpan">(accept)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotAuthorized">
            function <span class="apidocSignatureSpan">director.</span>http.NotAuthorized
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotFound">
            function <span class="apidocSignatureSpan">director.</span>http.NotFound
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotImplemented">
            function <span class="apidocSignatureSpan">director.</span>http.NotImplemented
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotModified">
            function <span class="apidocSignatureSpan">director.</span>http.NotModified
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router">
            function <span class="apidocSignatureSpan">director.</span>http.Router
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.attach">
            function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.attach
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.configure">
            function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.dispatch">
            function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.dispatch
            <span class="apidocSignatureSpan">(req, res, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.on">
            function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.on
            <span class="apidocSignatureSpan">(method, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.parse">
            function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.parse
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">director.</span>Router.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">director.</span>cli</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">director.</span>cli.Router.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">director.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">director.</span>http.Router.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">director.</span>http.Router.prototype.parsers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router">module director.Router</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.Router">
            function <span class="apidocSignatureSpan">director.</span>Router
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype">module director.Router.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.configure">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.dispatch">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>dispatch
            <span class="apidocSignatureSpan">(method, path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.extend">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>extend
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.insert">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>insert
            <span class="apidocSignatureSpan">(method, path, route, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.invoke">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>invoke
            <span class="apidocSignatureSpan">(fns, thisArg, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.mount">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>mount
            <span class="apidocSignatureSpan">(routes, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.on">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>on
            <span class="apidocSignatureSpan">(method, path, route)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.param">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>param
            <span class="apidocSignatureSpan">(token, matcher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.path">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>path
            <span class="apidocSignatureSpan">(path, routesFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.route">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>route
            <span class="apidocSignatureSpan">(method, path, route)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.runlist">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>runlist
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.traverse">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>traverse
            <span class="apidocSignatureSpan">(method, path, routes, regexp, filter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.configure">module director.Router.prototype.configure</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.configure.configure">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.dispatch">module director.Router.prototype.dispatch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.dispatch.dispatch">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>dispatch
            <span class="apidocSignatureSpan">(method, path, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.extend">module director.Router.prototype.extend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.extend.extend">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>extend
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.insert">module director.Router.prototype.insert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.insert.insert">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>insert
            <span class="apidocSignatureSpan">(method, path, route, parent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.invoke">module director.Router.prototype.invoke</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.invoke.invoke">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>invoke
            <span class="apidocSignatureSpan">(fns, thisArg, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.mount">module director.Router.prototype.mount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.mount.mount">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>mount
            <span class="apidocSignatureSpan">(routes, path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.param">module director.Router.prototype.param</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.param.param">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>param
            <span class="apidocSignatureSpan">(token, matcher)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.path">module director.Router.prototype.path</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.path.path">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>path
            <span class="apidocSignatureSpan">(path, routesFn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.route">module director.Router.prototype.route</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.route.route">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>route
            <span class="apidocSignatureSpan">(method, path, route)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.runlist">module director.Router.prototype.runlist</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.runlist.runlist">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>runlist
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.Router.prototype.traverse">module director.Router.prototype.traverse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.Router.prototype.traverse.traverse">
            function <span class="apidocSignatureSpan">director.Router.prototype.</span>traverse
            <span class="apidocSignatureSpan">(method, path, routes, regexp, filter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.cli">module director.cli</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router">
            function <span class="apidocSignatureSpan">director.cli.</span>Router
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.cli.Router">module director.cli.Router</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router.Router">
            function <span class="apidocSignatureSpan">director.cli.</span>Router
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router.super_">
            function <span class="apidocSignatureSpan">director.cli.Router.</span>super_
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.cli.Router.prototype">module director.cli.Router.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router.prototype.configure">
            function <span class="apidocSignatureSpan">director.cli.Router.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router.prototype.dispatch">
            function <span class="apidocSignatureSpan">director.cli.Router.prototype.</span>dispatch
            <span class="apidocSignatureSpan">(method, path, tty, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.cli.Router.prototype.configure">module director.cli.Router.prototype.configure</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router.prototype.configure.configure">
            function <span class="apidocSignatureSpan">director.cli.Router.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.cli.Router.prototype.dispatch">module director.cli.Router.prototype.dispatch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.cli.Router.prototype.dispatch.dispatch">
            function <span class="apidocSignatureSpan">director.cli.Router.prototype.</span>dispatch
            <span class="apidocSignatureSpan">(method, path, tty, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http">module director.http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.BadRequest">
            function <span class="apidocSignatureSpan">director.http.</span>BadRequest
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Forbidden">
            function <span class="apidocSignatureSpan">director.http.</span>Forbidden
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.MethodNotAllowed">
            function <span class="apidocSignatureSpan">director.http.</span>MethodNotAllowed
            <span class="apidocSignatureSpan">(allowed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotAcceptable">
            function <span class="apidocSignatureSpan">director.http.</span>NotAcceptable
            <span class="apidocSignatureSpan">(accept)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotAuthorized">
            function <span class="apidocSignatureSpan">director.http.</span>NotAuthorized
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotFound">
            function <span class="apidocSignatureSpan">director.http.</span>NotFound
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotImplemented">
            function <span class="apidocSignatureSpan">director.http.</span>NotImplemented
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotModified">
            function <span class="apidocSignatureSpan">director.http.</span>NotModified
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router">
            function <span class="apidocSignatureSpan">director.http.</span>Router
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">director.http.</span>methods</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.BadRequest">module director.http.BadRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.BadRequest.BadRequest">
            function <span class="apidocSignatureSpan">director.http.</span>BadRequest
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.BadRequest.super_">
            function <span class="apidocSignatureSpan">director.http.BadRequest.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Forbidden">module director.http.Forbidden</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Forbidden.Forbidden">
            function <span class="apidocSignatureSpan">director.http.</span>Forbidden
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Forbidden.super_">
            function <span class="apidocSignatureSpan">director.http.Forbidden.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.MethodNotAllowed">module director.http.MethodNotAllowed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.MethodNotAllowed.MethodNotAllowed">
            function <span class="apidocSignatureSpan">director.http.</span>MethodNotAllowed
            <span class="apidocSignatureSpan">(allowed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.MethodNotAllowed.super_">
            function <span class="apidocSignatureSpan">director.http.MethodNotAllowed.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.NotAcceptable">module director.http.NotAcceptable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotAcceptable.NotAcceptable">
            function <span class="apidocSignatureSpan">director.http.</span>NotAcceptable
            <span class="apidocSignatureSpan">(accept)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotAcceptable.super_">
            function <span class="apidocSignatureSpan">director.http.NotAcceptable.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.NotAuthorized">module director.http.NotAuthorized</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotAuthorized.NotAuthorized">
            function <span class="apidocSignatureSpan">director.http.</span>NotAuthorized
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotAuthorized.super_">
            function <span class="apidocSignatureSpan">director.http.NotAuthorized.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.NotFound">module director.http.NotFound</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotFound.NotFound">
            function <span class="apidocSignatureSpan">director.http.</span>NotFound
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotFound.super_">
            function <span class="apidocSignatureSpan">director.http.NotFound.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.NotImplemented">module director.http.NotImplemented</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotImplemented.NotImplemented">
            function <span class="apidocSignatureSpan">director.http.</span>NotImplemented
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotImplemented.super_">
            function <span class="apidocSignatureSpan">director.http.NotImplemented.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.NotModified">module director.http.NotModified</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotModified.NotModified">
            function <span class="apidocSignatureSpan">director.http.</span>NotModified
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.NotModified.super_">
            function <span class="apidocSignatureSpan">director.http.NotModified.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Router">module director.http.Router</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.Router">
            function <span class="apidocSignatureSpan">director.http.</span>Router
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.super_">
            function <span class="apidocSignatureSpan">director.http.Router.</span>super_
            <span class="apidocSignatureSpan">(routes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Router.prototype">module director.http.Router.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.attach">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>attach
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.configure">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.dispatch">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>dispatch
            <span class="apidocSignatureSpan">(req, res, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.on">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>on
            <span class="apidocSignatureSpan">(method, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.parse">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>parse
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">director.http.Router.prototype.</span>parsers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Router.prototype.attach">module director.http.Router.prototype.attach</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.attach.attach">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>attach
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Router.prototype.configure">module director.http.Router.prototype.configure</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.configure.configure">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>configure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Router.prototype.dispatch">module director.http.Router.prototype.dispatch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.dispatch.dispatch">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>dispatch
            <span class="apidocSignatureSpan">(req, res, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Router.prototype.on">module director.http.Router.prototype.on</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.on.on">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>on
            <span class="apidocSignatureSpan">(method, path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Router.prototype.parse">module director.http.Router.prototype.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.director.http.Router.prototype.parse.parse">
            function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>parse
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.director.http.Router.prototype.parsers">module director.http.Router.prototype.parsers</a><ol>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director" id="apidoc.module.director">module director</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router" id="apidoc.element.director.Router">
        function <span class="apidocSignatureSpan">director.</span>Router
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (routes) {
  this.params   = {};
  this.routes   = {};
  this.methods  = ['on', 'after', 'before'];
  this.scope    = [];
  this._methods = {};

  this.configure();
  this.mount(routes || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.res.writeHead(200, { 'Content-Type': 'text/plain' })
  this.res.end('hello world');
}

//
// define a routing table.
//
var router = new director.http.<span class="apidocCodeKeywordSpan">Router</span>({
  '/hello': {
    get: helloWorld
  }
});

//
// setup a server and when there is a request, dispatch the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.configure" id="apidoc.element.director.Router.prototype.configure">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.configure = function (options) {
  options = options || {};

  for (var i = 0; i &lt; this.methods.length; i++) {
    this._methods[this.methods[i]] = true;
  }

  this.recurse   = typeof options.recurse === 'undefined' ? this.recurse || false : options.recurse;
  this.async     = options.async     || false;
  this.delimiter = options.delimiter || '\/';
  this.strict    = typeof options.strict === 'undefined' ? true : options.strict;
  this.notfound  = options.notfound;
  this.resource  = options.resource;

  // Client only, but browser.js does not include a super implementation
  this.history     = (options.html5history &amp;&amp; this.historySupport) || false;
  this.run_in_init = (this.history === true &amp;&amp; options.run_handler_in_init !== false);
  this.convert_hash_in_init = (this.history === true &amp;&amp; options.convert_hash_in_init !== false);

  //
  // TODO: Global once
  //
  this.every = {
    after: options.after || null,
    before: options.before || null,
    on: options.on || null
  };

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.dispatch" id="apidoc.element.director.Router.prototype.dispatch">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.dispatch
        <span class="apidocSignatureSpan">(method, path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.dispatch = function (method, path, callback) {
  var self = this,
      fns = this.traverse(method, path.replace(QUERY_SEPARATOR, ''), this.routes, ''),
      invoked = this._invoked,
      after;

  this._invoked = true;
  if (!fns || fns.length === 0) {
    this.last = [];
    if (typeof this.notfound === 'function') {
      this.invoke([this.notfound], { method: method, path: path }, callback);
    }

    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  function updateAndInvoke() {
    self.last = fns.after;
    self.invoke(self.runlist(fns), self, callback);
  }

  //
  // Builds the list of functions to invoke from this call
  // to dispatch conforming to the following order:
  //
  // 1. Global after (if any)
  // 2. After functions from the last call to dispatch
  // 3. Global before (if any)
  // 4. Global on (if any)
  // 5. Matched functions from routing table (`['before', 'on'], ['before', 'on`], ...]`)
  //
  after = this.every &amp;&amp; this.every.after
    ? [this.every.after].concat(this.last)
    : [this.last];

  if (after &amp;&amp; after.length &gt; 0 &amp;&amp; invoked) {
    if (this.async) {
      this.invoke(after, this, updateAndInvoke);
    }
    else {
      this.invoke(after, this);
      updateAndInvoke();
    }

    return true;
  }

  updateAndInvoke();
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.extend" id="apidoc.element.director.Router.prototype.extend">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.extend
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.extend = function (methods) {
  var self = this,
      len = methods.length,
      i;

  function extend(method) {
    self._methods[method] = true;
    self[method] = function () {
      var extra = arguments.length === 1
        ? [method, '']
        : [method];

      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));
    };
  }

  for (i = 0; i &lt; len; i++) {
    extend(methods[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.insert" id="apidoc.element.director.Router.prototype.insert">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.insert
        <span class="apidocSignatureSpan">(method, path, route, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.insert = function (method, path, route, parent) {
  var methodType,
      parentType,
      isArray,
      nested,
      part;

  path = path.filter(function (p) {
    return p &amp;&amp; p.length &gt; 0;
  });

  parent = parent || this.routes;
  part = path.shift();
  if (/\:|\*/.test(part) &amp;&amp; !/\\d|\\w/.test(part)) {
    part = regifyString(part, this.params);
  }

  if (path.length &gt; 0) {
    //
    // If this is not the last part left in the `path`
    // (e.g. `['cities', 'new-york']`) then recurse into that
    // child
    //
    parent[part] = parent[part] || {};
    return this.insert(method, path, route, parent[part]);
  }

  //
  // If there is no part and the path has been exhausted
  // and the parent is the root of the routing table,
  // then we are inserting into the root and should
  // only dive one level deep in the Routing Table.
  //
  if (!part &amp;&amp; !path.length &amp;&amp; parent === this.routes) {
    methodType = typeof parent[method];

    switch (methodType) {
      case 'function':
        parent[method] = [parent[method], route];
        return;
      case 'object':
        parent[method].push(route);
        return;
      case 'undefined':
        parent[method] = route;
        return;
    }

    return;
  }

  //
  // Otherwise, we are at the end of our insertion so we should
  // insert the `route` based on the `method` after getting the
  // `parent` of the last `part`.
  //
  parentType = typeof parent[part];
  isArray = Array.isArray(parent[part]);

  if (parent[part] &amp;&amp; !isArray &amp;&amp; parentType == 'object') {
    methodType = typeof parent[part][method];

    switch (methodType) {
      case 'function':
        parent[part][method] = [parent[part][method], route];
        return;
      case 'object':
        parent[part][method].push(route);
        return;
      case 'undefined':
        parent[part][method] = route;
        return;
    }
  }
  else if (parentType == 'undefined') {
    nested = {};
    nested[method] = route;
    parent[part] = nested;
    return;
  }

  throw new Error('Invalid route context: ' + parentType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.invoke" id="apidoc.element.director.Router.prototype.invoke">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.invoke
        <span class="apidocSignatureSpan">(fns, thisArg, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.invoke = function (fns, thisArg, callback) {
  var self = this;

  var apply;
  if (this.async) {
    apply = function(fn, next){
      if (Array.isArray(fn)) {
        return _asyncEverySeries(fn, apply, next);
      }
      else if (typeof fn == 'function') {
        fn.apply(thisArg, (fns.captures || []).concat(next));
      }
    };
    _asyncEverySeries(fns, apply, function () {
      //
      // Ignore the response here. Let the routed take care
      // of themselves and eagerly return true.
      //

      if (callback) {
        callback.apply(thisArg, arguments);
      }
    });
  }
  else {
    apply = function(fn){
      if (Array.isArray(fn)) {
        return _every(fn, apply);
      }
      else if (typeof fn === 'function') {
        return fn.apply(thisArg, fns.captures || []);
      }
      else if (typeof fn === 'string' &amp;&amp; self.resource) {
        self.resource[fn].apply(thisArg, fns.captures || []);
      }
    }
    _every(fns, apply);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.mount" id="apidoc.element.director.Router.prototype.mount">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.mount
        <span class="apidocSignatureSpan">(routes, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.mount = function (routes, path) {
  if (!routes || typeof routes !== "object" || Array.isArray(routes)) {
    return;
  }

  var self = this;
  path = path || [];
  if (!Array.isArray(path)) {
    path = path.split(self.delimiter);
  }

  function insertOrMount(route, local) {
    var rename = route,
        parts = route.split(self.delimiter),
        routeType = typeof routes[route],
        isRoute = parts[0] === "" || !self._methods[parts[0]],
        event = isRoute ? "on" : rename;

    if (isRoute) {
      rename = rename.slice((rename.match(new RegExp('^' + self.delimiter)) || [''])[0].length);
      parts.shift();
    }

    if (isRoute &amp;&amp; routeType === 'object' &amp;&amp; !Array.isArray(routes[route])) {
      local = local.concat(parts);
      self.mount(routes[route], local);
      return;
    }

    if (isRoute) {
      local = local.concat(rename.split(self.delimiter));
      local = terminator(local, self.delimiter);
    }

    self.insert(event, local, routes[route]);
  }

  for (var route in routes) {
    if (routes.hasOwnProperty(route)) {
      insertOrMount(route, path.slice(0));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.param" id="apidoc.element.director.Router.prototype.param">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.param
        <span class="apidocSignatureSpan">(token, matcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.param = function (token, matcher) {
  if (token[0] !== ':') {
    token = ':' + token;
  }

  var compiled = new RegExp(token, 'g');
  this.params[token] = function (str) {
    return str.replace(compiled, matcher.source || matcher);
  };
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.path" id="apidoc.element.director.Router.prototype.path">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.path
        <span class="apidocSignatureSpan">(path, routesFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.path = function (path, routesFn) {
  var self = this,
      length = this.scope.length;

  if (path.source) {
    path = path.source.replace(/\\\//ig, '/');
  }

  //
  // ### Split the route up by the delimiter.
  //
  path = path.split(new RegExp(this.delimiter));

  //
  // ### Fix unterminated groups.
  //
  path = terminator(path, this.delimiter);
  this.scope = this.scope.concat(path);

  routesFn.call(this, this);
  this.scope.splice(length, path.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.route" id="apidoc.element.director.Router.prototype.route">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.route
        <span class="apidocSignatureSpan">(method, path, route)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.route = function (method, path, route) {
  var self = this;

  if (!route &amp;&amp; typeof path == 'function') {
    //
    // If only two arguments are supplied then assume this
    // `route` was meant to be a generic `on`.
    //
    route = path;
    path = method;
    method = 'on';
  }

  if (Array.isArray(path)) {
    return path.forEach(function(p) {
      self.on(method, p, route);
    });
  }

  if (path.source) {
    path = path.source.replace(/\\\//ig, '/');
  }

  if (Array.isArray(method)) {
    return method.forEach(function (m) {
      self.on(m.toLowerCase(), path, route);
    });
  }

  //
  // ### Split the route up by the delimiter.
  //
  path = path.split(new RegExp(this.delimiter));

  //
  // ### Fix unterminated groups. Fixes #59
  //
  path = terminator(path, this.delimiter);

  this.insert(method, this.scope.concat(path), route);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.runlist" id="apidoc.element.director.Router.prototype.runlist">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.runlist
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.runlist = function (fns) {
  var runlist = this.every &amp;&amp; this.every.before
    ? [this.every.before].concat(_flatten(fns))
    : _flatten(fns);

  if (this.every &amp;&amp; this.every.on) {
    runlist.push(this.every.on);
  }

  runlist.captures = fns.captures;
  runlist.source = fns.source;
  return runlist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.traverse" id="apidoc.element.director.Router.prototype.traverse">
        function <span class="apidocSignatureSpan">director.</span>Router.prototype.traverse
        <span class="apidocSignatureSpan">(method, path, routes, regexp, filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router.prototype.traverse = function (method, path, routes, regexp, filter) {
  var fns = [],
      current,
      exact,
      match,
      next,
      that;

  function filterRoutes(routes) {
    if (!filter) {
      return routes;
    }

    function deepCopy(source) {
      var result = [];
      for (var i = 0; i &lt; source.length; i++) {
        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];
      }
      return result;
    }

    function applyFilter(fns) {
      for (var i = fns.length - 1; i &gt;= 0; i--) {
        if (Array.isArray(fns[i])) {
          applyFilter(fns[i]);
          if (fns[i].length === 0) {
            fns.splice(i, 1);
          }
        }
        else {
          if (!filter(fns[i])) {
            fns.splice(i, 1);
          }
        }
      }
    }

    var newRoutes = deepCopy(routes);
    newRoutes.matched = routes.matched;
    newRoutes.captures = routes.captures;
    newRoutes.after = routes.after.filter(filter);

    applyFilter(newRoutes);

    return newRoutes;
  }

  //
  // Base Case #1:
  // If we are dispatching from the root
  // then only check if the method exists.
  //
  if (path === this.delimiter &amp;&amp; routes[method]) {
    next = [[routes.before, routes[method]].filter(Boolean)];
    next.after = [routes.after].filter(Boolean);
    next.matched = true;
    next.captures = [];
    return filterRoutes(next);
  }

  for (var r in routes) {
    //
    // We dont have an exact match, lets explore the tree
    // in a depth-first, recursive, in-order manner where
    // order is defined as:
    //
    //    ['before', 'on', '&lt;method&gt;', 'after']
    //
    // Remember to ignore keys (i.e. values of `r`) which
    // are actual methods (e.g. `on`, `before`, etc), but
    // which are not actual nested route (i.e. JSON literals).
    //
    if (routes.hasOwnProperty(r) &amp;&amp; (!this._methods[r] ||
      this._methods[r] &amp;&amp; typeof routes[r] === 'object' &amp;&amp; !Array.isArray(routes[r]))) {
      //
      // Attempt to make an exact match for the current route
      // which is built from the `regexp` that has been built
      // through recursive iteration.
      //
      current = exact = regexp + this.delimiter + r;

      if (!this.strict) {
        exact += '[' + this.delimiter + ']?';
      }

      match = path.match(new RegExp('^' + exact));

      if (!match) {
        //
        // If there isn't a `match` then continue. Here, the
        // `match` is a partial match. e.g.
        //
        //    '/foo/bar/buzz'.match(/^\/foo/)   // ['/foo']
        //    '/no-match/route'.match(/^\/foo/) // null
        //
        continue;
      }

      if (match[0] &amp;&amp; match[0] == path &amp;&amp; routes[r][method]) {
        //
        // ### Base case 2:
        // If we had a `match` and the capture is the path itself,
        // then we have completed our recursion.
        //
        next = [[routes[r].before, routes[r][method]].filter(Boolean)];
        next.after = [routes[r].after].filter(Boolean);
        next.matched = true;
        next.captures = match.slice(1);

        if (this.recurse &amp;&amp; routes === this.routes) {
          next.push([routes.before, routes.on].filter(Boolean));
          next.after = next.after.concat([routes.after].filter(Boolean));
        }

        return filterRoutes(next);
      }

      //
      // ### Recursive case:
      // If we had a match, but it is not yet an exact match then
      // attempt to continue matching against the next portion of the
      // routing table.
      //
      next = this.traverse(method, path, routes[r], current);

      //
      // `next.matched` will be true if the depth-first search of the routing
      // table from this position was successful.
      //
      if (next.matched) {
        //
        // Build the in-place tree structure representing the function
        // in the correct order.
        //
        if (next.length &gt; 0) {
          fns = fns.concat(next);
        }

        if (this.recurse) {
          fns.push([routes[r].before, routes[r][method]].filter(Boolean));
          next.after = next.after.concat([routes[r].after].f ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.cli.Router" id="apidoc.element.director.cli.Router">
        function <span class="apidocSignatureSpan">director.</span>cli.Router
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cli.Router = function (routes) {
  BaseRouter.call(this, routes);
  this.recurse = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Director supports Command Line Interface routing. Routes for cli options are
based on command line input (i.e. `process.argv`) instead of a URL.

``` js
var director = require('director');

var router = new director.<span class="apidocCodeKeywordSpan">cli.Router</span>();

router.on('create', function () {
  console.log('create something');
});

router.on(/destroy/, function () {
  console.log('destroy something');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.cli.Router.prototype.configure" id="apidoc.element.director.cli.Router.prototype.configure">
        function <span class="apidocSignatureSpan">director.</span>cli.Router.prototype.configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cli.Router.prototype.configure = function (options) {
  options = options || {};
  BaseRouter.prototype.configure.call(this, options);

  //
  // Delimiter must always be `\s` in CLI routing.
  // e.g. `jitsu users create`
  //
  this.delimiter = '\\s';
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.cli.Router.prototype.dispatch" id="apidoc.element.director.cli.Router.prototype.dispatch">
        function <span class="apidocSignatureSpan">director.</span>cli.Router.prototype.dispatch
        <span class="apidocSignatureSpan">(method, path, tty, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cli.Router.prototype.dispatch = function (method, path, tty, callback) {
  //
  // Prepend a single space onto the path so that the traversal
  // algorithm will recognize it. This is because we always assume
  // that the `path` begins with `this.delimiter`.
  //
  path = ' ' + path;
  var fns = this.traverse(method, path, this.routes, '');
  if (!fns || fns.length === 0) {
    if (typeof this.notfound === 'function') {
      this.notfound.call({ tty: tty, cmd: path }, callback);
    }
    else if (callback) {
      callback(new Error('Could not find path: ' + path));
    }

    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  this.invoke(this.runlist(fns), { tty: tty, cmd: path }, callback);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.BadRequest" id="apidoc.element.director.http.BadRequest">
        function <span class="apidocSignatureSpan">director.</span>http.BadRequest
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.BadRequest = function (msg) {
  msg = msg || 'Bad request';

  this.status = 400;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Forbidden" id="apidoc.element.director.http.Forbidden">
        function <span class="apidocSignatureSpan">director.</span>http.Forbidden
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.Forbidden = function (msg) {
  msg = msg || 'Not Authorized';

  this.status = 403;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.MethodNotAllowed" id="apidoc.element.director.http.MethodNotAllowed">
        function <span class="apidocSignatureSpan">director.</span>http.MethodNotAllowed
        <span class="apidocSignatureSpan">(allowed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.MethodNotAllowed = function (allowed) {
  var msg = 'method not allowed.';

  this.status = 405;
  this.headers = { allow: allowed };
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotAcceptable" id="apidoc.element.director.http.NotAcceptable">
        function <span class="apidocSignatureSpan">director.</span>http.NotAcceptable
        <span class="apidocSignatureSpan">(accept)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.NotAcceptable = function (accept) {
  var msg = 'cannot generate "' + accept + '" response';

  this.status = 406;
  this.headers = {};
  this.message = msg;
  this.body = {
    error: msg,
    only: 'application/json'
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotAuthorized" id="apidoc.element.director.http.NotAuthorized">
        function <span class="apidocSignatureSpan">director.</span>http.NotAuthorized
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.NotAuthorized = function (msg) {
  msg = msg || 'Not Authorized';

  this.status = 401;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotFound" id="apidoc.element.director.http.NotFound">
        function <span class="apidocSignatureSpan">director.</span>http.NotFound
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.NotFound = function (msg) {
  msg = msg || 'Not Found';

  this.status = 404;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotImplemented" id="apidoc.element.director.http.NotImplemented">
        function <span class="apidocSignatureSpan">director.</span>http.NotImplemented
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.NotImplemented = function (msg) {
  msg = msg || 'Not Implemented';

  this.status = 501;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotModified" id="apidoc.element.director.http.NotModified">
        function <span class="apidocSignatureSpan">director.</span>http.NotModified
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.NotModified = function () {
  this.status = 304;
  this.options = {
    removeContentHeaders: true
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router" id="apidoc.element.director.http.Router">
        function <span class="apidocSignatureSpan">director.</span>http.Router
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.Router = function (routes) {
  //
  // ### Extend the `Router` prototype with all of the RFC methods.
  //
  this.params   = {};
  this.routes   = {};
  this.methods  = ['on', 'after', 'before'];
  this.scope    = [];
  this._methods = {};
  this.recurse = 'forward';
  this._attach = [];

  this.extend(exports.methods.concat(['before', 'after']));
  this.configure();
  this.mount(routes || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.res.writeHead(200, { 'Content-Type': 'text/plain' })
  this.res.end('hello world');
}

//
// define a routing table.
//
var router = new director.<span class="apidocCodeKeywordSpan">http.Router</span>({
  '/hello': {
    get: helloWorld
  }
});

//
// setup a server and when there is a request, dispatch the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.attach" id="apidoc.element.director.http.Router.prototype.attach">
        function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.attach
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.Router.prototype.attach = function (func) {
  this._attach.push(func);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.configure" id="apidoc.element.director.http.Router.prototype.configure">
        function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.Router.prototype.configure = function (options) {
  options = options || {};

  // useful when using connect's bodyParser
  this.stream = options.stream || false;

  return BaseRouter.prototype.configure.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.dispatch" id="apidoc.element.director.http.Router.prototype.dispatch">
        function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.dispatch
        <span class="apidocSignatureSpan">(req, res, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.Router.prototype.dispatch = function (req, res, callback) {
  //
  // Dispatch `HEAD` requests to `GET`
  //
  var method = req.method === 'HEAD' ? 'get' : req.method.toLowerCase(),
      thisArg = { req: req, res: res },
      self = this,
      contentType,
      runlist,
      stream,
      error,
      fns,
      url;

  //
  // Trap bad URLs from `decodeUri`
  //
  try { url = decodeURI(req.url.split('?', 1)[0]); }
  catch (ex) { url = null }

  if (url &amp;&amp; this._hasAccepts) {
    contentType = req.headers['content-type'];
    fns = this.traverse(method, url, this.routes, '', function (route) {
      return !route.accept || route.accept.some(function (a) {
        return a.test(contentType);
      });
    });
  }
  else if (url) {
    fns = this.traverse(method, url, this.routes, '');
  }

  if (this._attach) {
    for (var i = 0; i &lt; this._attach.length; i++) {
      this._attach[i].call(thisArg);
    }
  }

  if (!fns || fns.length === 0) {
    error = new exports.NotFound('Could not find path: ' + req.url);
    if (typeof this.notfound === 'function') {
      this.notfound.call(thisArg, callback);
    }
    else if (callback) {
      callback.call(thisArg, error, req, res);
    }
    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  runlist = this.runlist(fns);
  stream  = this.stream || runlist.some(function (fn) { return fn.stream === true; });

  function parseAndInvoke() {
    error = self.parse(req);
    if (error) {
      if (callback) {
        callback.call(thisArg, error, req, res);
      }
      return false;
    }

    self.invoke(runlist, thisArg, callback);
  }

  if (!stream) {
    //
    // If there is no streaming required on any of the functions on the
    // way to `path`, then attempt to parse the fully buffered request stream
    // once it has emitted the `end` event.
    //
    if (req.readable) {
      //
      // If the `http.ServerRequest` is still readable, then await
      // the end event and then continue
      //
      req.once('end', parseAndInvoke);
      // Streams2 requires us to start the stream if we're not explicitly
      // reading from it.
      req.resume();
    }
    else {
      //
      // Otherwise, just parse the body now.
      //
      parseAndInvoke();
    }
  }
  else {
    this.invoke(runlist, thisArg, callback);
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.on" id="apidoc.element.director.http.Router.prototype.on">
        function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.on
        <span class="apidocSignatureSpan">(method, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.Router.prototype.on = function (method, path) {
  var args = Array.prototype.slice.call(arguments, 2),
      route = args.pop(),
      options = args.pop(),
      accept;

  if (options) {
    if (options.stream) {
      route.stream = true;
    }

    if (options.accept) {
      this._hasAccepts = true;
      accept = options.accept;
      route.accept = (Array.isArray(accept) ? accept : [accept]).map(function (a) {
        return typeof a === 'string' ? RegExp(a) : a;
      });
    }
  }

  if (typeof path !== 'string' &amp;&amp; !path.source) {
    path = '';
  }

  BaseRouter.prototype.on.call(this, method, path, route);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.parse" id="apidoc.element.director.http.Router.prototype.parse">
        function <span class="apidocSignatureSpan">director.</span>http.Router.prototype.parse
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http.Router.prototype.parse = function (req) {
  function mime(req) {
    var str = req.headers['content-type'] || '';
    return str.split(';')[0];
  }

  var parser = this.parsers[mime(req)],
      body;

  if (parser) {
    req.body = req.body || '';

    if (req.chunks) {
      req.chunks.forEach(function (chunk) {
        req.body += chunk;
      });
    }

    if ('string' === typeof req.body) {
      try {
        req.body = req.body &amp;&amp; req.body.length
          ? parser(req.body)
          : {};
      }
      catch (err) {
        return new exports.BadRequest('Malformed data');
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router" id="apidoc.module.director.Router">module director.Router</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.Router" id="apidoc.element.director.Router.Router">
        function <span class="apidocSignatureSpan">director.</span>Router
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (routes) {
  this.params   = {};
  this.routes   = {};
  this.methods  = ['on', 'after', 'before'];
  this.scope    = [];
  this._methods = {};

  this.configure();
  this.mount(routes || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.res.writeHead(200, { 'Content-Type': 'text/plain' })
  this.res.end('hello world');
}

//
// define a routing table.
//
var router = new director.http.<span class="apidocCodeKeywordSpan">Router</span>({
  '/hello': {
    get: helloWorld
  }
});

//
// setup a server and when there is a request, dispatch the
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype" id="apidoc.module.director.Router.prototype">module director.Router.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.configure" id="apidoc.element.director.Router.prototype.configure">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
  options = options || {};

  for (var i = 0; i &lt; this.methods.length; i++) {
    this._methods[this.methods[i]] = true;
  }

  this.recurse   = typeof options.recurse === 'undefined' ? this.recurse || false : options.recurse;
  this.async     = options.async     || false;
  this.delimiter = options.delimiter || '\/';
  this.strict    = typeof options.strict === 'undefined' ? true : options.strict;
  this.notfound  = options.notfound;
  this.resource  = options.resource;

  // Client only, but browser.js does not include a super implementation
  this.history     = (options.html5history &amp;&amp; this.historySupport) || false;
  this.run_in_init = (this.history === true &amp;&amp; options.run_handler_in_init !== false);
  this.convert_hash_in_init = (this.history === true &amp;&amp; options.convert_hash_in_init !== false);

  //
  // TODO: Global once
  //
  this.every = {
    after: options.after || null,
    before: options.before || null,
    on: options.on || null
  };

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // instantiate the router.
    //
    var router = Router(routes);

    //
    // a global configuration setting.
    //
    router.<span class="apidocCodeKeywordSpan">configure</span>({
      on: allroutes
    });

    router.init();
  });
  &lt;/script&gt;
&lt;/head&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.dispatch" id="apidoc.element.director.Router.prototype.dispatch">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>dispatch
        <span class="apidocSignatureSpan">(method, path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatch = function (method, path, callback) {
  var self = this,
      fns = this.traverse(method, path.replace(QUERY_SEPARATOR, ''), this.routes, ''),
      invoked = this._invoked,
      after;

  this._invoked = true;
  if (!fns || fns.length === 0) {
    this.last = [];
    if (typeof this.notfound === 'function') {
      this.invoke([this.notfound], { method: method, path: path }, callback);
    }

    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  function updateAndInvoke() {
    self.last = fns.after;
    self.invoke(self.runlist(fns), self, callback);
  }

  //
  // Builds the list of functions to invoke from this call
  // to dispatch conforming to the following order:
  //
  // 1. Global after (if any)
  // 2. After functions from the last call to dispatch
  // 3. Global before (if any)
  // 4. Global on (if any)
  // 5. Matched functions from routing table (`['before', 'on'], ['before', 'on`], ...]`)
  //
  after = this.every &amp;&amp; this.every.after
    ? [this.every.after].concat(this.last)
    : [this.last];

  if (after &amp;&amp; after.length &gt; 0 &amp;&amp; invoked) {
    if (this.async) {
      this.invoke(after, this, updateAndInvoke);
    }
    else {
      this.invoke(after, this);
      updateAndInvoke();
    }

    return true;
  }

  updateAndInvoke();
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

//
// setup a server and when there is a request, dispatch the
// route that was requested in the request object.
//
var server = http.createServer(function (req, res) {
  router.<span class="apidocCodeKeywordSpan">dispatch</span>(req, res, function (err) {
    if (err) {
      res.writeHead(404);
      res.end();
    }
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.extend" id="apidoc.element.director.Router.prototype.extend">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>extend
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (methods) {
  var self = this,
      len = methods.length,
      i;

  function extend(method) {
    self._methods[method] = true;
    self[method] = function () {
      var extra = arguments.length === 1
        ? [method, '']
        : [method];

      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));
    };
  }

  for (i = 0; i &lt; len; i++) {
    extend(methods[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.insert" id="apidoc.element.director.Router.prototype.insert">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>insert
        <span class="apidocSignatureSpan">(method, path, route, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (method, path, route, parent) {
  var methodType,
      parentType,
      isArray,
      nested,
      part;

  path = path.filter(function (p) {
    return p &amp;&amp; p.length &gt; 0;
  });

  parent = parent || this.routes;
  part = path.shift();
  if (/\:|\*/.test(part) &amp;&amp; !/\\d|\\w/.test(part)) {
    part = regifyString(part, this.params);
  }

  if (path.length &gt; 0) {
    //
    // If this is not the last part left in the `path`
    // (e.g. `['cities', 'new-york']`) then recurse into that
    // child
    //
    parent[part] = parent[part] || {};
    return this.insert(method, path, route, parent[part]);
  }

  //
  // If there is no part and the path has been exhausted
  // and the parent is the root of the routing table,
  // then we are inserting into the root and should
  // only dive one level deep in the Routing Table.
  //
  if (!part &amp;&amp; !path.length &amp;&amp; parent === this.routes) {
    methodType = typeof parent[method];

    switch (methodType) {
      case 'function':
        parent[method] = [parent[method], route];
        return;
      case 'object':
        parent[method].push(route);
        return;
      case 'undefined':
        parent[method] = route;
        return;
    }

    return;
  }

  //
  // Otherwise, we are at the end of our insertion so we should
  // insert the `route` based on the `method` after getting the
  // `parent` of the last `part`.
  //
  parentType = typeof parent[part];
  isArray = Array.isArray(parent[part]);

  if (parent[part] &amp;&amp; !isArray &amp;&amp; parentType == 'object') {
    methodType = typeof parent[part][method];

    switch (methodType) {
      case 'function':
        parent[part][method] = [parent[part][method], route];
        return;
      case 'object':
        parent[part][method].push(route);
        return;
      case 'undefined':
        parent[part][method] = route;
        return;
    }
  }
  else if (parentType == 'undefined') {
    nested = {};
    nested[method] = route;
    parent[part] = nested;
    return;
  }

  throw new Error('Invalid route context: ' + parentType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.invoke" id="apidoc.element.director.Router.prototype.invoke">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>invoke
        <span class="apidocSignatureSpan">(fns, thisArg, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invoke = function (fns, thisArg, callback) {
  var self = this;

  var apply;
  if (this.async) {
    apply = function(fn, next){
      if (Array.isArray(fn)) {
        return _asyncEverySeries(fn, apply, next);
      }
      else if (typeof fn == 'function') {
        fn.apply(thisArg, (fns.captures || []).concat(next));
      }
    };
    _asyncEverySeries(fns, apply, function () {
      //
      // Ignore the response here. Let the routed take care
      // of themselves and eagerly return true.
      //

      if (callback) {
        callback.apply(thisArg, arguments);
      }
    });
  }
  else {
    apply = function(fn){
      if (Array.isArray(fn)) {
        return _every(fn, apply);
      }
      else if (typeof fn === 'function') {
        return fn.apply(thisArg, fns.captures || []);
      }
      else if (typeof fn === 'string' &amp;&amp; self.resource) {
        self.resource[fn].apply(thisArg, fns.captures || []);
      }
    }
    _every(fns, apply);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.mount" id="apidoc.element.director.Router.prototype.mount">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>mount
        <span class="apidocSignatureSpan">(routes, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mount = function (routes, path) {
  if (!routes || typeof routes !== "object" || Array.isArray(routes)) {
    return;
  }

  var self = this;
  path = path || [];
  if (!Array.isArray(path)) {
    path = path.split(self.delimiter);
  }

  function insertOrMount(route, local) {
    var rename = route,
        parts = route.split(self.delimiter),
        routeType = typeof routes[route],
        isRoute = parts[0] === "" || !self._methods[parts[0]],
        event = isRoute ? "on" : rename;

    if (isRoute) {
      rename = rename.slice((rename.match(new RegExp('^' + self.delimiter)) || [''])[0].length);
      parts.shift();
    }

    if (isRoute &amp;&amp; routeType === 'object' &amp;&amp; !Array.isArray(routes[route])) {
      local = local.concat(parts);
      self.mount(routes[route], local);
      return;
    }

    if (isRoute) {
      local = local.concat(rename.split(self.delimiter));
      local = terminator(local, self.delimiter);
    }

    self.insert(event, local, routes[route]);
  }

  for (var route in routes) {
    if (routes.hasOwnProperty(route)) {
      insertOrMount(route, path.slice(0));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.on" id="apidoc.element.director.Router.prototype.on">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>on
        <span class="apidocSignatureSpan">(method, path, route)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (method, path, route) {
  var self = this;

  if (!route &amp;&amp; typeof path == 'function') {
    //
    // If only two arguments are supplied then assume this
    // `route` was meant to be a generic `on`.
    //
    route = path;
    path = method;
    method = 'on';
  }

  if (Array.isArray(path)) {
    return path.forEach(function(p) {
      self.on(method, p, route);
    });
  }

  if (path.source) {
    path = path.source.replace(/\\\//ig, '/');
  }

  if (Array.isArray(method)) {
    return method.forEach(function (m) {
      self.on(m.toLowerCase(), path, route);
    });
  }

  //
  // ### Split the route up by the delimiter.
  //
  path = path.split(new RegExp(this.delimiter));

  //
  // ### Fix unterminated groups. Fixes #59
  //
  path = terminator(path, this.delimiter);

  this.insert(method, this.scope.concat(path), route);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
based on command line input (i.e. `process.argv`) instead of a URL.

``` js
var director = require('director');

var router = new director.cli.Router();

router.<span class="apidocCodeKeywordSpan">on</span>('create', function () {
  console.log('create something');
});

router.on(/destroy/, function () {
  console.log('destroy something');
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.param" id="apidoc.element.director.Router.prototype.param">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>param
        <span class="apidocSignatureSpan">(token, matcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">param = function (token, matcher) {
  if (token[0] !== ':') {
    token = ':' + token;
  }

  var compiled = new RegExp(token, 'g');
  this.params[token] = function (str) {
    return str.replace(compiled, matcher.source || matcher);
  };
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// A route could be defined using the `userId` explicitly.
//
router.on(/([\w-_]+)/, function (userId) { });

//
// Define a shorthand for this fragment called `userId`.
//
router.<span class="apidocCodeKeywordSpan">param</span>('userId', /([\\w\\-]+)/);

//
// Now multiple routes can be defined with the same
// regular expression.
//
router.on('/anything/:userId', function (userId) { });
router.on('/something-else/:userId', function (userId) { });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.path" id="apidoc.element.director.Router.prototype.path">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>path
        <span class="apidocSignatureSpan">(path, routesFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">path = function (path, routesFn) {
  var self = this,
      length = this.scope.length;

  if (path.source) {
    path = path.source.replace(/\\\//ig, '/');
  }

  //
  // ### Split the route up by the delimiter.
  //
  path = path.split(new RegExp(this.delimiter));

  //
  // ### Fix unterminated groups.
  //
  path = terminator(path, this.delimiter);
  this.scope = this.scope.concat(path);

  routesFn.call(this, this);
  this.scope.splice(length, path.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
  var router = new director.http.Router();

  //
  // Create routes inside the `/users` scope.
  //
  router.<span class="apidocCodeKeywordSpan">path</span>(/\/users\/(\w+)/, function () {
//
// The `this` context of the function passed to `.path()`
// is the Router itself.
//

this.post(function (id) {
  //
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.route" id="apidoc.element.director.Router.prototype.route">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>route
        <span class="apidocSignatureSpan">(method, path, route)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">route = function (method, path, route) {
  var self = this;

  if (!route &amp;&amp; typeof path == 'function') {
    //
    // If only two arguments are supplied then assume this
    // `route` was meant to be a generic `on`.
    //
    route = path;
    path = method;
    method = 'on';
  }

  if (Array.isArray(path)) {
    return path.forEach(function(p) {
      self.on(method, p, route);
    });
  }

  if (path.source) {
    path = path.source.replace(/\\\//ig, '/');
  }

  if (Array.isArray(method)) {
    return method.forEach(function (m) {
      self.on(m.toLowerCase(), path, route);
    });
  }

  //
  // ### Split the route up by the delimiter.
  //
  path = path.split(new RegExp(this.delimiter));

  //
  // ### Fix unterminated groups. Fixes #59
  //
  path = terminator(path, this.delimiter);

  this.insert(method, this.scope.concat(path), route);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.runlist" id="apidoc.element.director.Router.prototype.runlist">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>runlist
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runlist = function (fns) {
  var runlist = this.every &amp;&amp; this.every.before
    ? [this.every.before].concat(_flatten(fns))
    : _flatten(fns);

  if (this.every &amp;&amp; this.every.on) {
    runlist.push(this.every.on);
  }

  runlist.captures = fns.captures;
  runlist.source = fns.source;
  return runlist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.Router.prototype.traverse" id="apidoc.element.director.Router.prototype.traverse">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>traverse
        <span class="apidocSignatureSpan">(method, path, routes, regexp, filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverse = function (method, path, routes, regexp, filter) {
  var fns = [],
      current,
      exact,
      match,
      next,
      that;

  function filterRoutes(routes) {
    if (!filter) {
      return routes;
    }

    function deepCopy(source) {
      var result = [];
      for (var i = 0; i &lt; source.length; i++) {
        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];
      }
      return result;
    }

    function applyFilter(fns) {
      for (var i = fns.length - 1; i &gt;= 0; i--) {
        if (Array.isArray(fns[i])) {
          applyFilter(fns[i]);
          if (fns[i].length === 0) {
            fns.splice(i, 1);
          }
        }
        else {
          if (!filter(fns[i])) {
            fns.splice(i, 1);
          }
        }
      }
    }

    var newRoutes = deepCopy(routes);
    newRoutes.matched = routes.matched;
    newRoutes.captures = routes.captures;
    newRoutes.after = routes.after.filter(filter);

    applyFilter(newRoutes);

    return newRoutes;
  }

  //
  // Base Case #1:
  // If we are dispatching from the root
  // then only check if the method exists.
  //
  if (path === this.delimiter &amp;&amp; routes[method]) {
    next = [[routes.before, routes[method]].filter(Boolean)];
    next.after = [routes.after].filter(Boolean);
    next.matched = true;
    next.captures = [];
    return filterRoutes(next);
  }

  for (var r in routes) {
    //
    // We dont have an exact match, lets explore the tree
    // in a depth-first, recursive, in-order manner where
    // order is defined as:
    //
    //    ['before', 'on', '&lt;method&gt;', 'after']
    //
    // Remember to ignore keys (i.e. values of `r`) which
    // are actual methods (e.g. `on`, `before`, etc), but
    // which are not actual nested route (i.e. JSON literals).
    //
    if (routes.hasOwnProperty(r) &amp;&amp; (!this._methods[r] ||
      this._methods[r] &amp;&amp; typeof routes[r] === 'object' &amp;&amp; !Array.isArray(routes[r]))) {
      //
      // Attempt to make an exact match for the current route
      // which is built from the `regexp` that has been built
      // through recursive iteration.
      //
      current = exact = regexp + this.delimiter + r;

      if (!this.strict) {
        exact += '[' + this.delimiter + ']?';
      }

      match = path.match(new RegExp('^' + exact));

      if (!match) {
        //
        // If there isn't a `match` then continue. Here, the
        // `match` is a partial match. e.g.
        //
        //    '/foo/bar/buzz'.match(/^\/foo/)   // ['/foo']
        //    '/no-match/route'.match(/^\/foo/) // null
        //
        continue;
      }

      if (match[0] &amp;&amp; match[0] == path &amp;&amp; routes[r][method]) {
        //
        // ### Base case 2:
        // If we had a `match` and the capture is the path itself,
        // then we have completed our recursion.
        //
        next = [[routes[r].before, routes[r][method]].filter(Boolean)];
        next.after = [routes[r].after].filter(Boolean);
        next.matched = true;
        next.captures = match.slice(1);

        if (this.recurse &amp;&amp; routes === this.routes) {
          next.push([routes.before, routes.on].filter(Boolean));
          next.after = next.after.concat([routes.after].filter(Boolean));
        }

        return filterRoutes(next);
      }

      //
      // ### Recursive case:
      // If we had a match, but it is not yet an exact match then
      // attempt to continue matching against the next portion of the
      // routing table.
      //
      next = this.traverse(method, path, routes[r], current);

      //
      // `next.matched` will be true if the depth-first search of the routing
      // table from this position was successful.
      //
      if (next.matched) {
        //
        // Build the in-place tree structure representing the function
        // in the correct order.
        //
        if (next.length &gt; 0) {
          fns = fns.concat(next);
        }

        if (this.recurse) {
          fns.push([routes[r].before, routes[r][method]].filter(Boolean));
          next.after = next.after.concat([routes[r].after].f ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.configure" id="apidoc.module.director.Router.prototype.configure">module director.Router.prototype.configure</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.configure.configure" id="apidoc.element.director.Router.prototype.configure.configure">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
  options = options || {};

  for (var i = 0; i &lt; this.methods.length; i++) {
    this._methods[this.methods[i]] = true;
  }

  this.recurse   = typeof options.recurse === 'undefined' ? this.recurse || false : options.recurse;
  this.async     = options.async     || false;
  this.delimiter = options.delimiter || '\/';
  this.strict    = typeof options.strict === 'undefined' ? true : options.strict;
  this.notfound  = options.notfound;
  this.resource  = options.resource;

  // Client only, but browser.js does not include a super implementation
  this.history     = (options.html5history &amp;&amp; this.historySupport) || false;
  this.run_in_init = (this.history === true &amp;&amp; options.run_handler_in_init !== false);
  this.convert_hash_in_init = (this.history === true &amp;&amp; options.convert_hash_in_init !== false);

  //
  // TODO: Global once
  //
  this.every = {
    after: options.after || null,
    before: options.before || null,
    on: options.on || null
  };

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // instantiate the router.
    //
    var router = Router(routes);

    //
    // a global configuration setting.
    //
    router.<span class="apidocCodeKeywordSpan">configure</span>({
      on: allroutes
    });

    router.init();
  });
  &lt;/script&gt;
&lt;/head&gt;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.dispatch" id="apidoc.module.director.Router.prototype.dispatch">module director.Router.prototype.dispatch</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.dispatch.dispatch" id="apidoc.element.director.Router.prototype.dispatch.dispatch">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>dispatch
        <span class="apidocSignatureSpan">(method, path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatch = function (method, path, callback) {
  var self = this,
      fns = this.traverse(method, path.replace(QUERY_SEPARATOR, ''), this.routes, ''),
      invoked = this._invoked,
      after;

  this._invoked = true;
  if (!fns || fns.length === 0) {
    this.last = [];
    if (typeof this.notfound === 'function') {
      this.invoke([this.notfound], { method: method, path: path }, callback);
    }

    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  function updateAndInvoke() {
    self.last = fns.after;
    self.invoke(self.runlist(fns), self, callback);
  }

  //
  // Builds the list of functions to invoke from this call
  // to dispatch conforming to the following order:
  //
  // 1. Global after (if any)
  // 2. After functions from the last call to dispatch
  // 3. Global before (if any)
  // 4. Global on (if any)
  // 5. Matched functions from routing table (`['before', 'on'], ['before', 'on`], ...]`)
  //
  after = this.every &amp;&amp; this.every.after
    ? [this.every.after].concat(this.last)
    : [this.last];

  if (after &amp;&amp; after.length &gt; 0 &amp;&amp; invoked) {
    if (this.async) {
      this.invoke(after, this, updateAndInvoke);
    }
    else {
      this.invoke(after, this);
      updateAndInvoke();
    }

    return true;
  }

  updateAndInvoke();
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

//
// setup a server and when there is a request, dispatch the
// route that was requested in the request object.
//
var server = http.createServer(function (req, res) {
  router.<span class="apidocCodeKeywordSpan">dispatch</span>(req, res, function (err) {
    if (err) {
      res.writeHead(404);
      res.end();
    }
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.extend" id="apidoc.module.director.Router.prototype.extend">module director.Router.prototype.extend</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.extend.extend" id="apidoc.element.director.Router.prototype.extend.extend">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>extend
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (methods) {
  var self = this,
      len = methods.length,
      i;

  function extend(method) {
    self._methods[method] = true;
    self[method] = function () {
      var extra = arguments.length === 1
        ? [method, '']
        : [method];

      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));
    };
  }

  for (i = 0; i &lt; len; i++) {
    extend(methods[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.insert" id="apidoc.module.director.Router.prototype.insert">module director.Router.prototype.insert</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.insert.insert" id="apidoc.element.director.Router.prototype.insert.insert">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>insert
        <span class="apidocSignatureSpan">(method, path, route, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (method, path, route, parent) {
  var methodType,
      parentType,
      isArray,
      nested,
      part;

  path = path.filter(function (p) {
    return p &amp;&amp; p.length &gt; 0;
  });

  parent = parent || this.routes;
  part = path.shift();
  if (/\:|\*/.test(part) &amp;&amp; !/\\d|\\w/.test(part)) {
    part = regifyString(part, this.params);
  }

  if (path.length &gt; 0) {
    //
    // If this is not the last part left in the `path`
    // (e.g. `['cities', 'new-york']`) then recurse into that
    // child
    //
    parent[part] = parent[part] || {};
    return this.insert(method, path, route, parent[part]);
  }

  //
  // If there is no part and the path has been exhausted
  // and the parent is the root of the routing table,
  // then we are inserting into the root and should
  // only dive one level deep in the Routing Table.
  //
  if (!part &amp;&amp; !path.length &amp;&amp; parent === this.routes) {
    methodType = typeof parent[method];

    switch (methodType) {
      case 'function':
        parent[method] = [parent[method], route];
        return;
      case 'object':
        parent[method].push(route);
        return;
      case 'undefined':
        parent[method] = route;
        return;
    }

    return;
  }

  //
  // Otherwise, we are at the end of our insertion so we should
  // insert the `route` based on the `method` after getting the
  // `parent` of the last `part`.
  //
  parentType = typeof parent[part];
  isArray = Array.isArray(parent[part]);

  if (parent[part] &amp;&amp; !isArray &amp;&amp; parentType == 'object') {
    methodType = typeof parent[part][method];

    switch (methodType) {
      case 'function':
        parent[part][method] = [parent[part][method], route];
        return;
      case 'object':
        parent[part][method].push(route);
        return;
      case 'undefined':
        parent[part][method] = route;
        return;
    }
  }
  else if (parentType == 'undefined') {
    nested = {};
    nested[method] = route;
    parent[part] = nested;
    return;
  }

  throw new Error('Invalid route context: ' + parentType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.invoke" id="apidoc.module.director.Router.prototype.invoke">module director.Router.prototype.invoke</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.invoke.invoke" id="apidoc.element.director.Router.prototype.invoke.invoke">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>invoke
        <span class="apidocSignatureSpan">(fns, thisArg, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invoke = function (fns, thisArg, callback) {
  var self = this;

  var apply;
  if (this.async) {
    apply = function(fn, next){
      if (Array.isArray(fn)) {
        return _asyncEverySeries(fn, apply, next);
      }
      else if (typeof fn == 'function') {
        fn.apply(thisArg, (fns.captures || []).concat(next));
      }
    };
    _asyncEverySeries(fns, apply, function () {
      //
      // Ignore the response here. Let the routed take care
      // of themselves and eagerly return true.
      //

      if (callback) {
        callback.apply(thisArg, arguments);
      }
    });
  }
  else {
    apply = function(fn){
      if (Array.isArray(fn)) {
        return _every(fn, apply);
      }
      else if (typeof fn === 'function') {
        return fn.apply(thisArg, fns.captures || []);
      }
      else if (typeof fn === 'string' &amp;&amp; self.resource) {
        self.resource[fn].apply(thisArg, fns.captures || []);
      }
    }
    _every(fns, apply);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.mount" id="apidoc.module.director.Router.prototype.mount">module director.Router.prototype.mount</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.mount.mount" id="apidoc.element.director.Router.prototype.mount.mount">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>mount
        <span class="apidocSignatureSpan">(routes, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mount = function (routes, path) {
  if (!routes || typeof routes !== "object" || Array.isArray(routes)) {
    return;
  }

  var self = this;
  path = path || [];
  if (!Array.isArray(path)) {
    path = path.split(self.delimiter);
  }

  function insertOrMount(route, local) {
    var rename = route,
        parts = route.split(self.delimiter),
        routeType = typeof routes[route],
        isRoute = parts[0] === "" || !self._methods[parts[0]],
        event = isRoute ? "on" : rename;

    if (isRoute) {
      rename = rename.slice((rename.match(new RegExp('^' + self.delimiter)) || [''])[0].length);
      parts.shift();
    }

    if (isRoute &amp;&amp; routeType === 'object' &amp;&amp; !Array.isArray(routes[route])) {
      local = local.concat(parts);
      self.mount(routes[route], local);
      return;
    }

    if (isRoute) {
      local = local.concat(rename.split(self.delimiter));
      local = terminator(local, self.delimiter);
    }

    self.insert(event, local, routes[route]);
  }

  for (var route in routes) {
    if (routes.hasOwnProperty(route)) {
      insertOrMount(route, path.slice(0));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.param" id="apidoc.module.director.Router.prototype.param">module director.Router.prototype.param</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.param.param" id="apidoc.element.director.Router.prototype.param.param">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>param
        <span class="apidocSignatureSpan">(token, matcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">param = function (token, matcher) {
  if (token[0] !== ':') {
    token = ':' + token;
  }

  var compiled = new RegExp(token, 'g');
  this.params[token] = function (str) {
    return str.replace(compiled, matcher.source || matcher);
  };
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// A route could be defined using the `userId` explicitly.
//
router.on(/([\w-_]+)/, function (userId) { });

//
// Define a shorthand for this fragment called `userId`.
//
router.<span class="apidocCodeKeywordSpan">param</span>('userId', /([\\w\\-]+)/);

//
// Now multiple routes can be defined with the same
// regular expression.
//
router.on('/anything/:userId', function (userId) { });
router.on('/something-else/:userId', function (userId) { });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.path" id="apidoc.module.director.Router.prototype.path">module director.Router.prototype.path</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.path.path" id="apidoc.element.director.Router.prototype.path.path">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>path
        <span class="apidocSignatureSpan">(path, routesFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">path = function (path, routesFn) {
  var self = this,
      length = this.scope.length;

  if (path.source) {
    path = path.source.replace(/\\\//ig, '/');
  }

  //
  // ### Split the route up by the delimiter.
  //
  path = path.split(new RegExp(this.delimiter));

  //
  // ### Fix unterminated groups.
  //
  path = terminator(path, this.delimiter);
  this.scope = this.scope.concat(path);

  routesFn.call(this, this);
  this.scope.splice(length, path.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

``` js
  var router = new director.http.Router();

  //
  // Create routes inside the `/users` scope.
  //
  router.<span class="apidocCodeKeywordSpan">path</span>(/\/users\/(\w+)/, function () {
//
// The `this` context of the function passed to `.path()`
// is the Router itself.
//

this.post(function (id) {
  //
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.route" id="apidoc.module.director.Router.prototype.route">module director.Router.prototype.route</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.route.route" id="apidoc.element.director.Router.prototype.route.route">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>route
        <span class="apidocSignatureSpan">(method, path, route)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">route = function (method, path, route) {
  var self = this;

  if (!route &amp;&amp; typeof path == 'function') {
    //
    // If only two arguments are supplied then assume this
    // `route` was meant to be a generic `on`.
    //
    route = path;
    path = method;
    method = 'on';
  }

  if (Array.isArray(path)) {
    return path.forEach(function(p) {
      self.on(method, p, route);
    });
  }

  if (path.source) {
    path = path.source.replace(/\\\//ig, '/');
  }

  if (Array.isArray(method)) {
    return method.forEach(function (m) {
      self.on(m.toLowerCase(), path, route);
    });
  }

  //
  // ### Split the route up by the delimiter.
  //
  path = path.split(new RegExp(this.delimiter));

  //
  // ### Fix unterminated groups. Fixes #59
  //
  path = terminator(path, this.delimiter);

  this.insert(method, this.scope.concat(path), route);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.runlist" id="apidoc.module.director.Router.prototype.runlist">module director.Router.prototype.runlist</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.runlist.runlist" id="apidoc.element.director.Router.prototype.runlist.runlist">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>runlist
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runlist = function (fns) {
  var runlist = this.every &amp;&amp; this.every.before
    ? [this.every.before].concat(_flatten(fns))
    : _flatten(fns);

  if (this.every &amp;&amp; this.every.on) {
    runlist.push(this.every.on);
  }

  runlist.captures = fns.captures;
  runlist.source = fns.source;
  return runlist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.Router.prototype.traverse" id="apidoc.module.director.Router.prototype.traverse">module director.Router.prototype.traverse</a></h1>


    <h2>
        <a href="#apidoc.element.director.Router.prototype.traverse.traverse" id="apidoc.element.director.Router.prototype.traverse.traverse">
        function <span class="apidocSignatureSpan">director.Router.prototype.</span>traverse
        <span class="apidocSignatureSpan">(method, path, routes, regexp, filter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverse = function (method, path, routes, regexp, filter) {
  var fns = [],
      current,
      exact,
      match,
      next,
      that;

  function filterRoutes(routes) {
    if (!filter) {
      return routes;
    }

    function deepCopy(source) {
      var result = [];
      for (var i = 0; i &lt; source.length; i++) {
        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];
      }
      return result;
    }

    function applyFilter(fns) {
      for (var i = fns.length - 1; i &gt;= 0; i--) {
        if (Array.isArray(fns[i])) {
          applyFilter(fns[i]);
          if (fns[i].length === 0) {
            fns.splice(i, 1);
          }
        }
        else {
          if (!filter(fns[i])) {
            fns.splice(i, 1);
          }
        }
      }
    }

    var newRoutes = deepCopy(routes);
    newRoutes.matched = routes.matched;
    newRoutes.captures = routes.captures;
    newRoutes.after = routes.after.filter(filter);

    applyFilter(newRoutes);

    return newRoutes;
  }

  //
  // Base Case #1:
  // If we are dispatching from the root
  // then only check if the method exists.
  //
  if (path === this.delimiter &amp;&amp; routes[method]) {
    next = [[routes.before, routes[method]].filter(Boolean)];
    next.after = [routes.after].filter(Boolean);
    next.matched = true;
    next.captures = [];
    return filterRoutes(next);
  }

  for (var r in routes) {
    //
    // We dont have an exact match, lets explore the tree
    // in a depth-first, recursive, in-order manner where
    // order is defined as:
    //
    //    ['before', 'on', '&lt;method&gt;', 'after']
    //
    // Remember to ignore keys (i.e. values of `r`) which
    // are actual methods (e.g. `on`, `before`, etc), but
    // which are not actual nested route (i.e. JSON literals).
    //
    if (routes.hasOwnProperty(r) &amp;&amp; (!this._methods[r] ||
      this._methods[r] &amp;&amp; typeof routes[r] === 'object' &amp;&amp; !Array.isArray(routes[r]))) {
      //
      // Attempt to make an exact match for the current route
      // which is built from the `regexp` that has been built
      // through recursive iteration.
      //
      current = exact = regexp + this.delimiter + r;

      if (!this.strict) {
        exact += '[' + this.delimiter + ']?';
      }

      match = path.match(new RegExp('^' + exact));

      if (!match) {
        //
        // If there isn't a `match` then continue. Here, the
        // `match` is a partial match. e.g.
        //
        //    '/foo/bar/buzz'.match(/^\/foo/)   // ['/foo']
        //    '/no-match/route'.match(/^\/foo/) // null
        //
        continue;
      }

      if (match[0] &amp;&amp; match[0] == path &amp;&amp; routes[r][method]) {
        //
        // ### Base case 2:
        // If we had a `match` and the capture is the path itself,
        // then we have completed our recursion.
        //
        next = [[routes[r].before, routes[r][method]].filter(Boolean)];
        next.after = [routes[r].after].filter(Boolean);
        next.matched = true;
        next.captures = match.slice(1);

        if (this.recurse &amp;&amp; routes === this.routes) {
          next.push([routes.before, routes.on].filter(Boolean));
          next.after = next.after.concat([routes.after].filter(Boolean));
        }

        return filterRoutes(next);
      }

      //
      // ### Recursive case:
      // If we had a match, but it is not yet an exact match then
      // attempt to continue matching against the next portion of the
      // routing table.
      //
      next = this.traverse(method, path, routes[r], current);

      //
      // `next.matched` will be true if the depth-first search of the routing
      // table from this position was successful.
      //
      if (next.matched) {
        //
        // Build the in-place tree structure representing the function
        // in the correct order.
        //
        if (next.length &gt; 0) {
          fns = fns.concat(next);
        }

        if (this.recurse) {
          fns.push([routes[r].before, routes[r][method]].filter(Boolean));
          next.after = next.after.concat([routes[r].after].f ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.cli" id="apidoc.module.director.cli">module director.cli</a></h1>


    <h2>
        <a href="#apidoc.element.director.cli.Router" id="apidoc.element.director.cli.Router">
        function <span class="apidocSignatureSpan">director.cli.</span>Router
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (routes) {
  BaseRouter.call(this, routes);
  this.recurse = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.res.writeHead(200, { 'Content-Type': 'text/plain' })
  this.res.end('hello world');
}

//
// define a routing table.
//
var router = new director.http.<span class="apidocCodeKeywordSpan">Router</span>({
  '/hello': {
    get: helloWorld
  }
});

//
// setup a server and when there is a request, dispatch the
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.cli.Router" id="apidoc.module.director.cli.Router">module director.cli.Router</a></h1>


    <h2>
        <a href="#apidoc.element.director.cli.Router.Router" id="apidoc.element.director.cli.Router.Router">
        function <span class="apidocSignatureSpan">director.cli.</span>Router
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (routes) {
  BaseRouter.call(this, routes);
  this.recurse = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.res.writeHead(200, { 'Content-Type': 'text/plain' })
  this.res.end('hello world');
}

//
// define a routing table.
//
var router = new director.http.<span class="apidocCodeKeywordSpan">Router</span>({
  '/hello': {
    get: helloWorld
  }
});

//
// setup a server and when there is a request, dispatch the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.cli.Router.super_" id="apidoc.element.director.cli.Router.super_">
        function <span class="apidocSignatureSpan">director.cli.Router.</span>super_
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (routes) {
  this.params   = {};
  this.routes   = {};
  this.methods  = ['on', 'after', 'before'];
  this.scope    = [];
  this._methods = {};

  this.configure();
  this.mount(routes || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.cli.Router.prototype" id="apidoc.module.director.cli.Router.prototype">module director.cli.Router.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.director.cli.Router.prototype.configure" id="apidoc.element.director.cli.Router.prototype.configure">
        function <span class="apidocSignatureSpan">director.cli.Router.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
  options = options || {};
  BaseRouter.prototype.configure.call(this, options);

  //
  // Delimiter must always be `\s` in CLI routing.
  // e.g. `jitsu users create`
  //
  this.delimiter = '\\s';
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // instantiate the router.
    //
    var router = Router(routes);

    //
    // a global configuration setting.
    //
    router.<span class="apidocCodeKeywordSpan">configure</span>({
      on: allroutes
    });

    router.init();
  });
  &lt;/script&gt;
&lt;/head&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.cli.Router.prototype.dispatch" id="apidoc.element.director.cli.Router.prototype.dispatch">
        function <span class="apidocSignatureSpan">director.cli.Router.prototype.</span>dispatch
        <span class="apidocSignatureSpan">(method, path, tty, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatch = function (method, path, tty, callback) {
  //
  // Prepend a single space onto the path so that the traversal
  // algorithm will recognize it. This is because we always assume
  // that the `path` begins with `this.delimiter`.
  //
  path = ' ' + path;
  var fns = this.traverse(method, path, this.routes, '');
  if (!fns || fns.length === 0) {
    if (typeof this.notfound === 'function') {
      this.notfound.call({ tty: tty, cmd: path }, callback);
    }
    else if (callback) {
      callback(new Error('Could not find path: ' + path));
    }

    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  this.invoke(this.runlist(fns), { tty: tty, cmd: path }, callback);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

//
// setup a server and when there is a request, dispatch the
// route that was requested in the request object.
//
var server = http.createServer(function (req, res) {
  router.<span class="apidocCodeKeywordSpan">dispatch</span>(req, res, function (err) {
    if (err) {
      res.writeHead(404);
      res.end();
    }
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.cli.Router.prototype.configure" id="apidoc.module.director.cli.Router.prototype.configure">module director.cli.Router.prototype.configure</a></h1>


    <h2>
        <a href="#apidoc.element.director.cli.Router.prototype.configure.configure" id="apidoc.element.director.cli.Router.prototype.configure.configure">
        function <span class="apidocSignatureSpan">director.cli.Router.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
  options = options || {};
  BaseRouter.prototype.configure.call(this, options);

  //
  // Delimiter must always be `\s` in CLI routing.
  // e.g. `jitsu users create`
  //
  this.delimiter = '\\s';
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // instantiate the router.
    //
    var router = Router(routes);

    //
    // a global configuration setting.
    //
    router.<span class="apidocCodeKeywordSpan">configure</span>({
      on: allroutes
    });

    router.init();
  });
  &lt;/script&gt;
&lt;/head&gt;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.cli.Router.prototype.dispatch" id="apidoc.module.director.cli.Router.prototype.dispatch">module director.cli.Router.prototype.dispatch</a></h1>


    <h2>
        <a href="#apidoc.element.director.cli.Router.prototype.dispatch.dispatch" id="apidoc.element.director.cli.Router.prototype.dispatch.dispatch">
        function <span class="apidocSignatureSpan">director.cli.Router.prototype.</span>dispatch
        <span class="apidocSignatureSpan">(method, path, tty, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatch = function (method, path, tty, callback) {
  //
  // Prepend a single space onto the path so that the traversal
  // algorithm will recognize it. This is because we always assume
  // that the `path` begins with `this.delimiter`.
  //
  path = ' ' + path;
  var fns = this.traverse(method, path, this.routes, '');
  if (!fns || fns.length === 0) {
    if (typeof this.notfound === 'function') {
      this.notfound.call({ tty: tty, cmd: path }, callback);
    }
    else if (callback) {
      callback(new Error('Could not find path: ' + path));
    }

    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  this.invoke(this.runlist(fns), { tty: tty, cmd: path }, callback);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

//
// setup a server and when there is a request, dispatch the
// route that was requested in the request object.
//
var server = http.createServer(function (req, res) {
  router.<span class="apidocCodeKeywordSpan">dispatch</span>(req, res, function (err) {
    if (err) {
      res.writeHead(404);
      res.end();
    }
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http" id="apidoc.module.director.http">module director.http</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.BadRequest" id="apidoc.element.director.http.BadRequest">
        function <span class="apidocSignatureSpan">director.http.</span>BadRequest
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BadRequest = function (msg) {
  msg = msg || 'Bad request';

  this.status = 400;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Forbidden" id="apidoc.element.director.http.Forbidden">
        function <span class="apidocSignatureSpan">director.http.</span>Forbidden
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Forbidden = function (msg) {
  msg = msg || 'Not Authorized';

  this.status = 403;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.MethodNotAllowed" id="apidoc.element.director.http.MethodNotAllowed">
        function <span class="apidocSignatureSpan">director.http.</span>MethodNotAllowed
        <span class="apidocSignatureSpan">(allowed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MethodNotAllowed = function (allowed) {
  var msg = 'method not allowed.';

  this.status = 405;
  this.headers = { allow: allowed };
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotAcceptable" id="apidoc.element.director.http.NotAcceptable">
        function <span class="apidocSignatureSpan">director.http.</span>NotAcceptable
        <span class="apidocSignatureSpan">(accept)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotAcceptable = function (accept) {
  var msg = 'cannot generate "' + accept + '" response';

  this.status = 406;
  this.headers = {};
  this.message = msg;
  this.body = {
    error: msg,
    only: 'application/json'
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotAuthorized" id="apidoc.element.director.http.NotAuthorized">
        function <span class="apidocSignatureSpan">director.http.</span>NotAuthorized
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotAuthorized = function (msg) {
  msg = msg || 'Not Authorized';

  this.status = 401;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotFound" id="apidoc.element.director.http.NotFound">
        function <span class="apidocSignatureSpan">director.http.</span>NotFound
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotFound = function (msg) {
  msg = msg || 'Not Found';

  this.status = 404;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotImplemented" id="apidoc.element.director.http.NotImplemented">
        function <span class="apidocSignatureSpan">director.http.</span>NotImplemented
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotImplemented = function (msg) {
  msg = msg || 'Not Implemented';

  this.status = 501;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotModified" id="apidoc.element.director.http.NotModified">
        function <span class="apidocSignatureSpan">director.http.</span>NotModified
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotModified = function () {
  this.status = 304;
  this.options = {
    removeContentHeaders: true
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router" id="apidoc.element.director.http.Router">
        function <span class="apidocSignatureSpan">director.http.</span>Router
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (routes) {
  //
  // ### Extend the `Router` prototype with all of the RFC methods.
  //
  this.params   = {};
  this.routes   = {};
  this.methods  = ['on', 'after', 'before'];
  this.scope    = [];
  this._methods = {};
  this.recurse = 'forward';
  this._attach = [];

  this.extend(exports.methods.concat(['before', 'after']));
  this.configure();
  this.mount(routes || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.res.writeHead(200, { 'Content-Type': 'text/plain' })
  this.res.end('hello world');
}

//
// define a routing table.
//
var router = new director.http.<span class="apidocCodeKeywordSpan">Router</span>({
  '/hello': {
    get: helloWorld
  }
});

//
// setup a server and when there is a request, dispatch the
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.BadRequest" id="apidoc.module.director.http.BadRequest">module director.http.BadRequest</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.BadRequest.BadRequest" id="apidoc.element.director.http.BadRequest.BadRequest">
        function <span class="apidocSignatureSpan">director.http.</span>BadRequest
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BadRequest = function (msg) {
  msg = msg || 'Bad request';

  this.status = 400;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.BadRequest.super_" id="apidoc.element.director.http.BadRequest.super_">
        function <span class="apidocSignatureSpan">director.http.BadRequest.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Forbidden" id="apidoc.module.director.http.Forbidden">module director.http.Forbidden</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.Forbidden.Forbidden" id="apidoc.element.director.http.Forbidden.Forbidden">
        function <span class="apidocSignatureSpan">director.http.</span>Forbidden
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Forbidden = function (msg) {
  msg = msg || 'Not Authorized';

  this.status = 403;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Forbidden.super_" id="apidoc.element.director.http.Forbidden.super_">
        function <span class="apidocSignatureSpan">director.http.Forbidden.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.MethodNotAllowed" id="apidoc.module.director.http.MethodNotAllowed">module director.http.MethodNotAllowed</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.MethodNotAllowed.MethodNotAllowed" id="apidoc.element.director.http.MethodNotAllowed.MethodNotAllowed">
        function <span class="apidocSignatureSpan">director.http.</span>MethodNotAllowed
        <span class="apidocSignatureSpan">(allowed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MethodNotAllowed = function (allowed) {
  var msg = 'method not allowed.';

  this.status = 405;
  this.headers = { allow: allowed };
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.MethodNotAllowed.super_" id="apidoc.element.director.http.MethodNotAllowed.super_">
        function <span class="apidocSignatureSpan">director.http.MethodNotAllowed.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.NotAcceptable" id="apidoc.module.director.http.NotAcceptable">module director.http.NotAcceptable</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.NotAcceptable.NotAcceptable" id="apidoc.element.director.http.NotAcceptable.NotAcceptable">
        function <span class="apidocSignatureSpan">director.http.</span>NotAcceptable
        <span class="apidocSignatureSpan">(accept)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotAcceptable = function (accept) {
  var msg = 'cannot generate "' + accept + '" response';

  this.status = 406;
  this.headers = {};
  this.message = msg;
  this.body = {
    error: msg,
    only: 'application/json'
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotAcceptable.super_" id="apidoc.element.director.http.NotAcceptable.super_">
        function <span class="apidocSignatureSpan">director.http.NotAcceptable.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.NotAuthorized" id="apidoc.module.director.http.NotAuthorized">module director.http.NotAuthorized</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.NotAuthorized.NotAuthorized" id="apidoc.element.director.http.NotAuthorized.NotAuthorized">
        function <span class="apidocSignatureSpan">director.http.</span>NotAuthorized
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotAuthorized = function (msg) {
  msg = msg || 'Not Authorized';

  this.status = 401;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotAuthorized.super_" id="apidoc.element.director.http.NotAuthorized.super_">
        function <span class="apidocSignatureSpan">director.http.NotAuthorized.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.NotFound" id="apidoc.module.director.http.NotFound">module director.http.NotFound</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.NotFound.NotFound" id="apidoc.element.director.http.NotFound.NotFound">
        function <span class="apidocSignatureSpan">director.http.</span>NotFound
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotFound = function (msg) {
  msg = msg || 'Not Found';

  this.status = 404;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotFound.super_" id="apidoc.element.director.http.NotFound.super_">
        function <span class="apidocSignatureSpan">director.http.NotFound.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.NotImplemented" id="apidoc.module.director.http.NotImplemented">module director.http.NotImplemented</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.NotImplemented.NotImplemented" id="apidoc.element.director.http.NotImplemented.NotImplemented">
        function <span class="apidocSignatureSpan">director.http.</span>NotImplemented
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotImplemented = function (msg) {
  msg = msg || 'Not Implemented';

  this.status = 501;
  this.headers = {};
  this.message = msg;
  this.body = { error: msg };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotImplemented.super_" id="apidoc.element.director.http.NotImplemented.super_">
        function <span class="apidocSignatureSpan">director.http.NotImplemented.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.NotModified" id="apidoc.module.director.http.NotModified">module director.http.NotModified</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.NotModified.NotModified" id="apidoc.element.director.http.NotModified.NotModified">
        function <span class="apidocSignatureSpan">director.http.</span>NotModified
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotModified = function () {
  this.status = 304;
  this.options = {
    removeContentHeaders: true
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.NotModified.super_" id="apidoc.element.director.http.NotModified.super_">
        function <span class="apidocSignatureSpan">director.http.NotModified.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Router" id="apidoc.module.director.http.Router">module director.http.Router</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.Router.Router" id="apidoc.element.director.http.Router.Router">
        function <span class="apidocSignatureSpan">director.http.</span>Router
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Router = function (routes) {
  //
  // ### Extend the `Router` prototype with all of the RFC methods.
  //
  this.params   = {};
  this.routes   = {};
  this.methods  = ['on', 'after', 'before'];
  this.scope    = [];
  this._methods = {};
  this.recurse = 'forward';
  this._attach = [];

  this.extend(exports.methods.concat(['before', 'after']));
  this.configure();
  this.mount(routes || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.res.writeHead(200, { 'Content-Type': 'text/plain' })
  this.res.end('hello world');
}

//
// define a routing table.
//
var router = new director.http.<span class="apidocCodeKeywordSpan">Router</span>({
  '/hello': {
    get: helloWorld
  }
});

//
// setup a server and when there is a request, dispatch the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.super_" id="apidoc.element.director.http.Router.super_">
        function <span class="apidocSignatureSpan">director.http.Router.</span>super_
        <span class="apidocSignatureSpan">(routes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (routes) {
  this.params   = {};
  this.routes   = {};
  this.methods  = ['on', 'after', 'before'];
  this.scope    = [];
  this._methods = {};

  this.configure();
  this.mount(routes || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Router.prototype" id="apidoc.module.director.http.Router.prototype">module director.http.Router.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.attach" id="apidoc.element.director.http.Router.prototype.attach">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>attach
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attach = function (func) {
  this._attach.push(func);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var director = require('director');

var router = new director.http.Router().configure(options);

//
// Attach properties to `this`
//
router.<span class="apidocCodeKeywordSpan">attach</span>(function () {
  this.data = [1,2,3];
});

//
// Access properties attached to `this` in your routes!
//
router.get('/hello', function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.configure" id="apidoc.element.director.http.Router.prototype.configure">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
  options = options || {};

  // useful when using connect's bodyParser
  this.stream = options.stream || false;

  return BaseRouter.prototype.configure.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // instantiate the router.
    //
    var router = Router(routes);

    //
    // a global configuration setting.
    //
    router.<span class="apidocCodeKeywordSpan">configure</span>({
      on: allroutes
    });

    router.init();
  });
  &lt;/script&gt;
&lt;/head&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.dispatch" id="apidoc.element.director.http.Router.prototype.dispatch">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>dispatch
        <span class="apidocSignatureSpan">(req, res, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatch = function (req, res, callback) {
  //
  // Dispatch `HEAD` requests to `GET`
  //
  var method = req.method === 'HEAD' ? 'get' : req.method.toLowerCase(),
      thisArg = { req: req, res: res },
      self = this,
      contentType,
      runlist,
      stream,
      error,
      fns,
      url;

  //
  // Trap bad URLs from `decodeUri`
  //
  try { url = decodeURI(req.url.split('?', 1)[0]); }
  catch (ex) { url = null }

  if (url &amp;&amp; this._hasAccepts) {
    contentType = req.headers['content-type'];
    fns = this.traverse(method, url, this.routes, '', function (route) {
      return !route.accept || route.accept.some(function (a) {
        return a.test(contentType);
      });
    });
  }
  else if (url) {
    fns = this.traverse(method, url, this.routes, '');
  }

  if (this._attach) {
    for (var i = 0; i &lt; this._attach.length; i++) {
      this._attach[i].call(thisArg);
    }
  }

  if (!fns || fns.length === 0) {
    error = new exports.NotFound('Could not find path: ' + req.url);
    if (typeof this.notfound === 'function') {
      this.notfound.call(thisArg, callback);
    }
    else if (callback) {
      callback.call(thisArg, error, req, res);
    }
    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  runlist = this.runlist(fns);
  stream  = this.stream || runlist.some(function (fn) { return fn.stream === true; });

  function parseAndInvoke() {
    error = self.parse(req);
    if (error) {
      if (callback) {
        callback.call(thisArg, error, req, res);
      }
      return false;
    }

    self.invoke(runlist, thisArg, callback);
  }

  if (!stream) {
    //
    // If there is no streaming required on any of the functions on the
    // way to `path`, then attempt to parse the fully buffered request stream
    // once it has emitted the `end` event.
    //
    if (req.readable) {
      //
      // If the `http.ServerRequest` is still readable, then await
      // the end event and then continue
      //
      req.once('end', parseAndInvoke);
      // Streams2 requires us to start the stream if we're not explicitly
      // reading from it.
      req.resume();
    }
    else {
      //
      // Otherwise, just parse the body now.
      //
      parseAndInvoke();
    }
  }
  else {
    this.invoke(runlist, thisArg, callback);
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

//
// setup a server and when there is a request, dispatch the
// route that was requested in the request object.
//
var server = http.createServer(function (req, res) {
  router.<span class="apidocCodeKeywordSpan">dispatch</span>(req, res, function (err) {
    if (err) {
      res.writeHead(404);
      res.end();
    }
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.on" id="apidoc.element.director.http.Router.prototype.on">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>on
        <span class="apidocSignatureSpan">(method, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (method, path) {
  var args = Array.prototype.slice.call(arguments, 2),
      route = args.pop(),
      options = args.pop(),
      accept;

  if (options) {
    if (options.stream) {
      route.stream = true;
    }

    if (options.accept) {
      this._hasAccepts = true;
      accept = options.accept;
      route.accept = (Array.isArray(accept) ? accept : [accept]).map(function (a) {
        return typeof a === 'string' ? RegExp(a) : a;
      });
    }
  }

  if (typeof path !== 'string' &amp;&amp; !path.source) {
    path = '';
  }

  BaseRouter.prototype.on.call(this, method, path, route);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
based on command line input (i.e. `process.argv`) instead of a URL.

``` js
var director = require('director');

var router = new director.cli.Router();

router.<span class="apidocCodeKeywordSpan">on</span>('create', function () {
  console.log('create something');
});

router.on(/destroy/, function () {
  console.log('destroy something');
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.parse" id="apidoc.element.director.http.Router.prototype.parse">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>parse
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (req) {
  function mime(req) {
    var str = req.headers['content-type'] || '';
    return str.split(';')[0];
  }

  var parser = this.parsers[mime(req)],
      body;

  if (parser) {
    req.body = req.body || '';

    if (req.chunks) {
      req.chunks.forEach(function (chunk) {
        req.body += chunk;
      });
    }

    if ('string' === typeof req.body) {
      try {
        req.body = req.body &amp;&amp; req.body.length
          ? parser(req.body)
          : {};
      }
      catch (err) {
        return new exports.BadRequest('Malformed data');
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Router.prototype.attach" id="apidoc.module.director.http.Router.prototype.attach">module director.http.Router.prototype.attach</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.attach.attach" id="apidoc.element.director.http.Router.prototype.attach.attach">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>attach
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attach = function (func) {
  this._attach.push(func);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var director = require('director');

var router = new director.http.Router().configure(options);

//
// Attach properties to `this`
//
router.<span class="apidocCodeKeywordSpan">attach</span>(function () {
  this.data = [1,2,3];
});

//
// Access properties attached to `this` in your routes!
//
router.get('/hello', function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Router.prototype.configure" id="apidoc.module.director.http.Router.prototype.configure">module director.http.Router.prototype.configure</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.configure.configure" id="apidoc.element.director.http.Router.prototype.configure.configure">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>configure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">configure = function (options) {
  options = options || {};

  // useful when using connect's bodyParser
  this.stream = options.stream || false;

  return BaseRouter.prototype.configure.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // instantiate the router.
    //
    var router = Router(routes);

    //
    // a global configuration setting.
    //
    router.<span class="apidocCodeKeywordSpan">configure</span>({
      on: allroutes
    });

    router.init();
  });
  &lt;/script&gt;
&lt;/head&gt;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Router.prototype.dispatch" id="apidoc.module.director.http.Router.prototype.dispatch">module director.http.Router.prototype.dispatch</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.dispatch.dispatch" id="apidoc.element.director.http.Router.prototype.dispatch.dispatch">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>dispatch
        <span class="apidocSignatureSpan">(req, res, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispatch = function (req, res, callback) {
  //
  // Dispatch `HEAD` requests to `GET`
  //
  var method = req.method === 'HEAD' ? 'get' : req.method.toLowerCase(),
      thisArg = { req: req, res: res },
      self = this,
      contentType,
      runlist,
      stream,
      error,
      fns,
      url;

  //
  // Trap bad URLs from `decodeUri`
  //
  try { url = decodeURI(req.url.split('?', 1)[0]); }
  catch (ex) { url = null }

  if (url &amp;&amp; this._hasAccepts) {
    contentType = req.headers['content-type'];
    fns = this.traverse(method, url, this.routes, '', function (route) {
      return !route.accept || route.accept.some(function (a) {
        return a.test(contentType);
      });
    });
  }
  else if (url) {
    fns = this.traverse(method, url, this.routes, '');
  }

  if (this._attach) {
    for (var i = 0; i &lt; this._attach.length; i++) {
      this._attach[i].call(thisArg);
    }
  }

  if (!fns || fns.length === 0) {
    error = new exports.NotFound('Could not find path: ' + req.url);
    if (typeof this.notfound === 'function') {
      this.notfound.call(thisArg, callback);
    }
    else if (callback) {
      callback.call(thisArg, error, req, res);
    }
    return false;
  }

  if (this.recurse === 'forward') {
    fns = fns.reverse();
  }

  runlist = this.runlist(fns);
  stream  = this.stream || runlist.some(function (fn) { return fn.stream === true; });

  function parseAndInvoke() {
    error = self.parse(req);
    if (error) {
      if (callback) {
        callback.call(thisArg, error, req, res);
      }
      return false;
    }

    self.invoke(runlist, thisArg, callback);
  }

  if (!stream) {
    //
    // If there is no streaming required on any of the functions on the
    // way to `path`, then attempt to parse the fully buffered request stream
    // once it has emitted the `end` event.
    //
    if (req.readable) {
      //
      // If the `http.ServerRequest` is still readable, then await
      // the end event and then continue
      //
      req.once('end', parseAndInvoke);
      // Streams2 requires us to start the stream if we're not explicitly
      // reading from it.
      req.resume();
    }
    else {
      //
      // Otherwise, just parse the body now.
      //
      parseAndInvoke();
    }
  }
  else {
    this.invoke(runlist, thisArg, callback);
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

//
// setup a server and when there is a request, dispatch the
// route that was requested in the request object.
//
var server = http.createServer(function (req, res) {
  router.<span class="apidocCodeKeywordSpan">dispatch</span>(req, res, function (err) {
    if (err) {
      res.writeHead(404);
      res.end();
    }
  });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Router.prototype.on" id="apidoc.module.director.http.Router.prototype.on">module director.http.Router.prototype.on</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.on.on" id="apidoc.element.director.http.Router.prototype.on.on">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>on
        <span class="apidocSignatureSpan">(method, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (method, path) {
  var args = Array.prototype.slice.call(arguments, 2),
      route = args.pop(),
      options = args.pop(),
      accept;

  if (options) {
    if (options.stream) {
      route.stream = true;
    }

    if (options.accept) {
      this._hasAccepts = true;
      accept = options.accept;
      route.accept = (Array.isArray(accept) ? accept : [accept]).map(function (a) {
        return typeof a === 'string' ? RegExp(a) : a;
      });
    }
  }

  if (typeof path !== 'string' &amp;&amp; !path.source) {
    path = '';
  }

  BaseRouter.prototype.on.call(this, method, path, route);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
based on command line input (i.e. `process.argv`) instead of a URL.

``` js
var director = require('director');

var router = new director.cli.Router();

router.<span class="apidocCodeKeywordSpan">on</span>('create', function () {
  console.log('create something');
});

router.on(/destroy/, function () {
  console.log('destroy something');
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Router.prototype.parse" id="apidoc.module.director.http.Router.prototype.parse">module director.http.Router.prototype.parse</a></h1>


    <h2>
        <a href="#apidoc.element.director.http.Router.prototype.parse.parse" id="apidoc.element.director.http.Router.prototype.parse.parse">
        function <span class="apidocSignatureSpan">director.http.Router.prototype.</span>parse
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (req) {
  function mime(req) {
    var str = req.headers['content-type'] || '';
    return str.split(';')[0];
  }

  var parser = this.parsers[mime(req)],
      body;

  if (parser) {
    req.body = req.body || '';

    if (req.chunks) {
      req.chunks.forEach(function (chunk) {
        req.body += chunk;
      });
    }

    if ('string' === typeof req.body) {
      try {
        req.body = req.body &amp;&amp; req.body.length
          ? parser(req.body)
          : {};
      }
      catch (err) {
        return new exports.BadRequest('Malformed data');
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.director.http.Router.prototype.parsers" id="apidoc.module.director.http.Router.prototype.parsers">module director.http.Router.prototype.parsers</a></h1>

</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>